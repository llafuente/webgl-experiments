<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js canvas - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #e0e0e0;
                margin: 0px;
                overflow: hidden;
            }
            canvas {
                border: 1px solid black;
                cursor: crosshair;
            }
            #tools img {
                border: 1px solid white;
                border-radius: 4px;
            }
            #tools .selected {
                border: 1px solid black;
            }
        </style>
        <script src="EventEmitter.js"></script>
        <script src="jquery-2.1.1.js"></script>
        <script src="three.js"></script>
        <script src="app.js"></script>
        <script src="utils.js"></script>

        <!-- app friendly -->
        <script src="controls/OrthographicZoom.js"></script>

        <!-- threejs -->
        <script src="controls/FlyControls.js"></script>
        <script src="controls/OrbitControls.js"></script>
        <script src="controls/OrthographicTrackballControls.js"></script>

        <script src="libs/stats.min.js"></script>

        <script data-src="shaders/vertex.js" type="x-shader/x-vertex" id="vertexshader"></script>
        <script data-src="shaders/fragment.js" type="x-shader/x-fragment" id="fragmentshader"></script>

    </head>

    <body>
        <div style="width:256px; position: absolute; right: 0;" id="tools">
          <div>
            <img id="tool-camera" class="selected" src="images/1409329287_film_camera_16mm.png" />
            <img id="tool-move" src="images/1409329351_move_alt1-64.png" />
            <img id="tool-push" src="images/1409329490_arrow_up_alt1-64.png" />
            <img id="tool-pull" src="images/1409329484_arrow_down_alt1-64.png" />
          </div>
          <div>
            <form id="scene">
             <legend>Scene Size</legend>
             <input type="number" id="scene_x" name="scene_x" value="200" />
             <input type="number" id="scene_y" name="scene_y" value="200" />
             <input type="submit" name="Change" value="Change" />
            </form>
            <form id="brush">
             <legend>Brush Size</legend>
             <input type="number" id="brush_x" name="brush_x" value="1" />
             <input type="number" id="brush_y" name="brush_y" value="1" />
             <select id="brush_amount" name="brush_amount">
               <option value="20">PULL</option>
               <option value="-20">PUSH</option>
             </select>
             <input type="submit" name="Change" value="Change" />
            </form>
          </div>
        </div>
    </body>
<script>
"use strict";

// http://jsfiddle.net/4Txgp/13/

function mark (position) {
    var geometry = new THREE.BoxGeometry(50, 50, 50);
    var material = new THREE.MeshPhongMaterial({color: 0xff0000});
    var cube = new THREE.Mesh(geometry, material);
    cube.position.x = position.x;
    cube.position.y = position.y;
    cube.position.z = position.z;
    this.scene.add(cube);
}

var camera2,
    uniforms,
    TPMaterial;

function createTPMaterial() {
    camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 100.0);
    camera2.position.x = 0;
    camera2.position.y = 10;
    camera2.position.z = 0;
    camera2.lookAt(new THREE.Vector3());
    camera2.updateProjectionMatrix();

    uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.lights, {
      time: { type:"f", value:0 },
      resolution: { type:"v2", value:new THREE.Vector2(viewportWidth, viewportHeight) },
      projectorWorldViewProjTransform: {type: "m4", value: null}
    }]);

    // do not include tex0 above it fails
    uniforms.tex0 = { type:"t", value: THREE.ImageUtils.loadTexture("mi2-3.gif") }
    uniforms.tex0.value.wrapS = uniforms.tex0.value.wrapT = THREE.Repeat;

    TPMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: shaders.vertexshader,
      fragmentShader: shaders.fragmentshader,
      lights: true
    });
}

var wireframe = new THREE.MeshPhongMaterial({
    color: 0x555555,
    wireframe: true,
});
wireframe.ambient = wireframe.color;

var app = new App();

app.createScene = function() {
    //this.cameras[0].debug();
    //this.cameras[1].debug();
    //this.cameras[2].debug();

    this.scene.add(new THREE.AmbientLight(0xffffff));


    // LIGHTS
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(110, 100, 10);

    light.castShadow = true;
    light.shadowCameraVisible = true;

    light.shadowMapWidth = 512;
    light.shadowMapHeight = 512;

    var d = 200;

    light.shadowCameraLeft = -d;
    light.shadowCameraRight = d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;

    light.shadowCameraFar = 1000;
    light.shadowDarkness = 0.75;

    this.scene.add(light);
/*
    var light = new THREE.SpotLight(0xffffff, 1, 0, Math.PI / 2, 1);
    light.position.set(500, 500, 500);
    light.target.position.set(0, 0, 0);

    light.castShadow = true;

    light.shadowCameraNear = 0;
    light.shadowCameraFar = 25000;
    light.shadowCameraFov = 45;

    light.shadowCameraRight    =  500;
    light.shadowCameraLeft     = -500;
    light.shadowCameraTop      =  500;
    light.shadowCameraBottom   = -500;


    //light.shadowCameraVisible = true;

    light.shadowBias = 0.0001;
    light.shadowDarkness = 0.5;

    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;

    light.shadowCameraVisible = true;

    this.scene.add(light);

    // Cubes
    var pixels = image_to_pixels(image, document.getElementById("ref-image-depth")),
        width = image.width,
        height = image.height,
        count = 0,
        box_size = 7;

    for (var i = 0; i < pixels.length; i += 4) {
        if (pixels[i] !== undefined) {
            var box_width = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3 / 50;
            var geometry = new THREE.BoxGeometry(box_size, box_size, box_size * box_width);

            for (var j = 0; j < geometry.faces.length; ++j) {
                geometry.faces[ j ].color.setRGB(pixels[i] / 255, pixels[i+1] / 255, pixels[i+2] / 255);
            }
            var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, overdraw: 0.5 });

            //var material = new THREE.MeshLambertMaterial({color: (pixels[i]) << 16 ^ (pixels[i+1] * 255) << 8 ^ (pixels[i+2] * 255) << 0, specular: 0xffffff, ambient: 0x000000 });
            //var material = new THREE.MeshPhongMaterial({color: (pixels[i]) << 16 ^ (pixels[i+1] * 255) << 8 ^ (pixels[i+2] * 255) << 0, specular: 0xffffff, ambient: 0x000000 });

            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;


            cube.position.x = (count % width) * box_size;
            cube.position.y = Math.floor(height - count / width) * box_size;
            //cube.position.x = (count % 20) * box_size;
            //cube.position.y = Math.floor(count / 20) * box_size;
            this.scene.add(cube);

        }
        ++count;
    }

    // Plane

    var geometry = new THREE.BoxGeometry(10, 10, 10);

    //var material = new THREE.MeshBasicMaterial({ color: 0xe0e0e0, overdraw: 0.5 });
    //var material = new THREE.MeshPhongMaterial({ color: 0xe0e0e0 });
    material.ambient = material.color;

    var box = new THREE.Mesh(geometry, material);
    this.scene.add(box);

    */

    // link scene size here!

    var material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
    var material = new THREE.MeshLambertMaterial({
        color: 0xffffff
    });
    var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: THREE.ImageUtils.loadTexture("images/Monkey_island_2_prison.png")
    });

    var resolution = [320, 200];

    var geometry = new THREE.PlaneGeometry(resolution[0], resolution[1], resolution[0], resolution[1]);
    geometry.applyMatrix(
        new THREE.Matrix4().makeRotationY(Math.PI)
    );

    console.log(geometry.vertices[0]);
    console.log(geometry.vertices[geometry.vertices.length - 1]);

    geometry.dynamic = true;

    var plane = new THREE.Mesh(geometry, material);

    plane.castShadow = true;
    plane.receiveShadow = true;
    plane.position.y = -0;
    this.scene.add(plane);

    function move_vertex(x, y, amount) {
        // y need to be inverted
        // console.log(x, y, amount);

        var idx = x +  y * (resolution[0] + 1);
        if (idx < geometry.vertices.length) {
            // push/pull
            geometry.vertices[idx].z += amount;
        }
    }

    // TODO offset cam.position.xy
    this.on("mousedown", function(event) {
        var tx = parseInt(jQuery("#brush_x").val(), 10),
            ty = parseInt(jQuery("#brush_y").val(), 10),
            amount = parseInt(jQuery("#brush_amount").val(), 10),
            x,
            y,
            cam = app.cameras[2],
            cfg = cam.$cfg,
            mouse_x = Math.floor(event.cameraX / cfg.aspectRatio),
            mouse_y = Math.floor(event.cameraIY / cfg.aspectRatio);

        var offset = [
            (cfg.width / cfg.aspectRatio - resolution[0]) * 0.5,
            (cfg.height / cfg.aspectRatio - resolution[1]) * 0.5
        ];

        console.log("offset", offset);

        if (app.lastSelectedCamera == cam) {

            for (x = 0; x < tx; ++x) {
                for (y = 0; y < ty; ++y) {
                    move_vertex(mouse_x + x - offset[0], mouse_y + y - offset[1], amount);
                    //move_vertex(0 + x, 0 + y, amount);
                }
            }

            geometry.verticesNeedUpdate = true;
        }
    });

    this.displayAxes();
};

$(document).ready(function() {
    app.init({
        width: 640 || window.innerWidth,
        height: 400 || window.innerHeight,
        images: ["images/Monkey_island_2_prison.png"],
        cameras: [{
            id: "isometric",
            background: 0xdddddd,
            // screen position, based on this will calculate real world size camera for you
            top: 1,
            bottom: 0.5,
            left: 0,
            right: 0.5,
            position: {x: 500, y: 500, z: 500},
            lookAt: {x: 0, y: 0, z:0}
        },{
            id: "isometric2",
            background: 0xeeeeee,
            top: 1,
            bottom: 0.5,
            left: 0.5,
            right: 1,
            position: {x: -500, y: 250, z: 500},
            lookAt: {x: 0, y: 0, z: 0}
        },{ // editors camera!
            id: "front",
            background: 0xdddddd,
            top: 0.5,
            bottom: 0,
            left: 0,
            right: 0.5,
            position: {x: 0, y: 0, z: 1000},
            lookAt: {x: 0, y: 0, z: 0},
            aspectRatio: 1,
            //overrideMaterial: wireframe
        },{
            id: "front45",
            background: 0xeeeeee,
            top: 0.5,
            bottom: 0,
            left: 0.5,
            right: 1,
            position: {x: 500, y: 250, z: 500},
            lookAt: {x: 0, y: 0, z: 0}
        }]
    });

    app.start();

    var projectorWorldViewProj = new THREE.Matrix4();

    app.on("frameStart", function() {
    });
});

</script>








